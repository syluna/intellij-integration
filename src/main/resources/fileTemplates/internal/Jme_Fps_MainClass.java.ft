package ${PACKAGE};

import com.jme3.app.SimpleApplication;
import com.jme3.bullet.BulletAppState;
import com.jme3.bullet.PhysicsSpace;
import com.jme3.bullet.control.BetterCharacterControl;
import com.jme3.bullet.control.RigidBodyControl;
import com.jme3.bullet.util.CollisionShapeFactory;
import com.jme3.environment.EnvironmentCamera;
import com.jme3.input.KeyInput;
import com.jme3.input.MouseInput;
import com.jme3.input.controls.ActionListener;
import com.jme3.input.controls.KeyTrigger;
import com.jme3.input.controls.MouseButtonTrigger;
import com.jme3.light.DirectionalLight;
import com.jme3.light.LightProbe;
import com.jme3.material.Material;
import com.jme3.material.TechniqueDef;
import com.jme3.math.ColorRGBA;
import com.jme3.math.Vector3f;
import com.jme3.post.FilterPostProcessor;
import com.jme3.post.filters.FXAAFilter;
import com.jme3.post.filters.ToneMapFilter;
import com.jme3.post.ssao.SSAOFilter;
import com.jme3.renderer.queue.RenderQueue;
import com.jme3.scene.Geometry;
import com.jme3.scene.Node;
import com.jme3.scene.Spatial;
import com.jme3.scene.shape.Sphere;
import com.jme3.shadow.DirectionalLightShadowFilter;
import com.jme3.system.AppSettings;

import java.util.ArrayList;
import java.util.List;

/**
 * A basic game template.
 * @author jayfella
 */
public class Main extends SimpleApplication implements ActionListener {

    public static void main(String[] args) {

        Main app = new Main();

        AppSettings settings = new AppSettings(true);
        settings.setTitle("My Awesome Game");
        settings.setResolution(1280, 720);
        settings.setSamples(16);
        settings.setGammaCorrection(true);
        app.setSettings(settings);

        app.start();

    }

    @Override
    public void simpleInitApp() {

        flyCam.setMoveSpeed(5);

        stateManager.attach(new EnvironmentCamera());

        // Enable physics...
        BulletAppState bulletAppState = new BulletAppState();
        bulletAppState.setDebugEnabled(false);
        stateManager.attach(bulletAppState);

        // Configure the scene for PBR
        getRenderManager().setPreferredLightMode(TechniqueDef.LightMode.SinglePassAndImageBased);
        getRenderManager().setSinglePassLightBatchSize(10);

        // Adjust to near frustum to a very close amount.
        float aspect = (float)cam.getWidth() / (float)cam.getHeight();
        cam.setFrustumPerspective(60, aspect, 0.1f, 1000);

        // change the viewport background color.
        viewPort.setBackgroundColor(new ColorRGBA(0.4f, 0.5f, 0.6f, 1.0f));

        // Add some lights
        DirectionalLight directionalLight = new DirectionalLight(
                new Vector3f(-1, -1, -1).normalizeLocal(),
                new ColorRGBA(1,1,1,1).multLocal(0.4f)
        );

        rootNode.addLight(directionalLight);

        // load a lightprobe from test-data
        Node probeNode = (Node) assetManager.loadModel("Scenes/defaultProbe.j3o");
        LightProbe lightProbe = (LightProbe) probeNode.getLocalLightList().get(0);
        rootNode.addLight(lightProbe);

        // Add some post-processor effects.
        initPostFx(directionalLight);

        // load in a scene and a player
        PhysicsSpace physicsSpace = bulletAppState.getPhysicsSpace();

        loadScene(physicsSpace);
        loadPlayer(physicsSpace);

        setUpKeys();

    }

    private void loadScene(PhysicsSpace physicsSpace) {
        Node level = (Node) assetManager.loadModel("Models/Scenes/fps.gltf.j3o");

        Spatial statics = level.getChild("Static");
        RigidBodyControl staticRigids = new RigidBodyControl(CollisionShapeFactory.createMeshShape(statics), 0);
        statics.addControl(staticRigids);
        physicsSpace.add(staticRigids);

        Node moveables = (Node) level.getChild("Moveables");

        for (Spatial child : moveables.getChildren()) {
            RigidBodyControl rigidBodyControl = new RigidBodyControl(CollisionShapeFactory.createDynamicMeshShape(child), 1.0f);
            child.addControl(rigidBodyControl);
            physicsSpace.add(rigidBodyControl);
        }

        rootNode.attachChild(level);
    }

    private Spatial pistol;

    private void loadPlayer(PhysicsSpace physicsSpace) {

        player = new BetterCharacterControl(0.5f, 2, 1);
        player.setJumpForce(new Vector3f(0, 20, 0));
        playerNode = new Node("Player");
        playerNode.addControl(player);

        rootNode.attachChild(playerNode);

        physicsSpace.add(player);

        player.warp(new Vector3f(0, 5, 0));

        pistol = assetManager.loadModel("Models/Pistol/Pistol.gltf.j3o");
        pistol.setLocalTranslation(0, 2f, 0.1f);
        playerNode.attachChild(pistol);

    }

    private void initPostFx(DirectionalLight directionalLight) {

        FilterPostProcessor fpp = new FilterPostProcessor(assetManager);

        DirectionalLightShadowFilter dlsf = new DirectionalLightShadowFilter(assetManager, 4096, 3);
        dlsf.setLight(directionalLight);
        fpp.addFilter(dlsf);

        rootNode.setShadowMode(RenderQueue.ShadowMode.CastAndReceive);

        SSAOFilter ssaoFilter = new SSAOFilter();
        fpp.addFilter(ssaoFilter);

        FXAAFilter fxaaFilter = new FXAAFilter();
        fpp.addFilter(fxaaFilter);

        ToneMapFilter toneMapFilter = new ToneMapFilter();
        fpp.addFilter(toneMapFilter);

        viewPort.addProcessor(fpp);

    }

    private BetterCharacterControl player;
    private Node playerNode;
    private Vector3f walkDirection = new Vector3f();
    private boolean left = false, right = false, up = false, down = false;

    //Temporary vectors used on each frame.
    //They here to avoid instanciating new vectors on each frame
    private Vector3f camDir = new Vector3f();
    private Vector3f camLeft = new Vector3f();

    /** We over-write some navigational key mappings here, so we can
     * add physics-controlled walking and jumping: */
    private void setUpKeys() {
        inputManager.addMapping("Left", new KeyTrigger(KeyInput.KEY_A));
        inputManager.addMapping("Right", new KeyTrigger(KeyInput.KEY_D));
        inputManager.addMapping("Up", new KeyTrigger(KeyInput.KEY_W));
        inputManager.addMapping("Down", new KeyTrigger(KeyInput.KEY_S));
        inputManager.addMapping("Jump", new KeyTrigger(KeyInput.KEY_SPACE));
        inputManager.addMapping("Shoot", new MouseButtonTrigger(MouseInput.BUTTON_LEFT));
        inputManager.addListener(this, "Left");
        inputManager.addListener(this, "Right");
        inputManager.addListener(this, "Up");
        inputManager.addListener(this, "Down");
        inputManager.addListener(this, "Jump");
        inputManager.addListener(this, "Shoot");

    }

    /** These are our custom actions triggered by key presses.
     * We do not walk yet, we just keep track of the direction the user pressed. */
    public void onAction(String binding, boolean isPressed, float tpf) {
        if (binding.equals("Left")) {
            left = isPressed;
        } else if (binding.equals("Right")) {
            right = isPressed;
        } else if (binding.equals("Up")) {
            up = isPressed;
        } else if (binding.equals("Down")) {
            down = isPressed;
        } else if (binding.equals("Jump")) {
            if (isPressed) {
                player.jump();
            }
        } else if (binding.equals("Shoot") && !isPressed) {

            Geometry bullet = new Geometry("Bullet", new Sphere(32, 32, 0.25f));
            bullet.setMaterial(new Material(assetManager, "Common/MatDefs/Light/PBRLighting.j3md"));
            bullet.getMaterial().setColor("BaseColor", ColorRGBA.Red);
            rootNode.attachChild(bullet);

            sceneBullets.add(new TimedBullet(bullet, 10));

            RigidBodyControl rigidBodyControl = new RigidBodyControl(CollisionShapeFactory.createDynamicMeshShape(bullet), 0.5f);
            bullet.addControl(rigidBodyControl);

            stateManager.getState(BulletAppState.class).getPhysicsSpace().add(rigidBodyControl);

            rigidBodyControl.setPhysicsLocation(cam.getLocation().add(cam.getDirection().mult(0.5f)));
            rigidBodyControl.setPhysicsRotation(cam.getRotation());
            rigidBodyControl.applyImpulse(cam.getDirection().mult(20), new Vector3f());


        }


    }

    /**
     * This is the main event loop--walking happens here.
     * We check in which direction the player is walking by interpreting
     * the camera direction forward (camDir) and to the side (camLeft).
     * The setWalkDirection() command is what lets a physics-controlled player walk.
     * We also make sure here that the camera moves with player.
     */
    @Override
    public void simpleUpdate(float tpf) {
        camDir.set(cam.getDirection()).multLocal(2.6f);
        camLeft.set(cam.getLeft()).multLocal(2.4f);

        camDir.setY(0);
        camLeft.setY(0);

        walkDirection.set(0, 0, 0);
        if (left) {
            walkDirection.addLocal(camLeft);
        }
        if (right) {
            walkDirection.addLocal(camLeft.negate());
        }
        if (up) {
            walkDirection.addLocal(camDir);
        }
        if (down) {
            walkDirection.addLocal(camDir.negate());
        }
        player.setWalkDirection(walkDirection);

        cam.setLocation(playerNode.getLocalTranslation().add(0, 2,0));

        sceneBullets.removeIf(bullet -> {

            if (bullet.updateTime(tpf) > bullet.getMaxTime()) {
                bullet.getSpatial().removeFromParent();
                RigidBodyControl rigidBodyControl = bullet.getSpatial().getControl(RigidBodyControl.class);
                getStateManager().getState(BulletAppState.class).getPhysicsSpace().remove(rigidBodyControl);
                return true;
            }

            return false;
        });
    }

    private final List<TimedBullet> sceneBullets = new ArrayList<>();

    private class TimedBullet {

        private final Spatial bullet;
        private final float maxTime;
        private float time;

        public TimedBullet(Spatial bullet, float maxTime) {
            this.bullet = bullet;
            this.maxTime = maxTime;
        }

        public Spatial getSpatial() {
            return bullet;
        }

        public float getMaxTime() {
            return maxTime;
        }

        public float getTime() {
            return time;
        }

        public float updateTime(float tpf) {
            time += tpf;
            return time;
        }

    }

}

